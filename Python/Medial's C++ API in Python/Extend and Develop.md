# Extend and Develop
The following document contains c++-low-level details needed to further develop the binding.
## Objectives
**Allow us to**
1. Utilize our API from Python.
2. Using Python as a "Glue Language".
3. Be able to use python for prototyping, exploration, discovery.
4. Interoperability with other frameworks.
5. Minimal maintenance overhead when updating code.
## Implementation
For easy maintenance I think **SWIG** is the best solution.
Other solutions exist, but...
1. Cython - A Python/C hybrid language - downside: adding another "language" to the process.
2. Boost::python - seem to have poor support and resource online. Requires maintening special definitions for each exported member.
3. ctypes — A foreign function library for Python - calls C functions directly but requires correctly defining the parameters, might not be binary compatible when moving to other platforms.
**So SWIG was chosen**
1. It's an old binding generator project but has a lot of online resources.
2. Managing memory and ownership of python objects is complicated. SWIG takes care of that.
3. NumPy support seems good.
**Our implementation - Presenting "MedPyExport"**
- A library that will be added to current Libs/Internal tree.
- It'll wrap our classes and export only the functions that we need and are usable under Python.
- All of us know C++ so this will require minimal learning curve to start contributing code to the python export lib.
- SWIG requires some definition files in a non-C++ format ( a single .i file that should be updated to enable NumPy typemaps). These can and will will be automatically generated from the code using scripts that are run during the building process.
**Notes and current pitfalls**:
1. vector<> should always be defined as std::vector.
2. After adding a new function or class it's best to 'shutdown' the jupyter notebook to fully relaod wrapper files.
3. Should use different names for numpy parameter of different types
4. No method overloading (but might be possible to implement)
5. No "big-data" looping - all actions should be implemented using a functional vectoric way using NumPy and Pandas
6. Buid system is seprate from the "create*cmake*files".
7. didn't find a way to convery data to a pandas DataFrame yet.
8. SWIG scanner can only deal with a very "simple c++ variant". We'll let it scan only the .h files and keep actual code separated in .cpp files. keep the scanner away from Medial libs and the standard libs using macros.
9. Compilation works both on Windows and Linus using separate build systems - a solution file for Windows and a cmake file for Linux. Execution was tested only on Linux(Node1) and on Jupyter.
**Build System**
The binding is aimed to be compiled and used on Linux nodes, however a VS soulution file was composed as well to provide the IDE support and ability to find compilation errors.
So compilation on Windows+VS works but it will not produce a binary loadable by (the Windows Version of) Python. 
Since the binding needs special directives in the CMake file for SWIG, it doesn't use the create*cmake *files output but a different specialized cmake file.
**directory structure**
The binding is placed in MR/Libs/Internal/ :
- * MedPyExport - contains VS solution and project files and the following subdirectories: *
  - * MedPyExport - contains source files for the project. *
  - * generate_binding - cmake files and other files related to the binding generation. *
    - * * MedPython - contains SWIG interface files 
      - * * * * scripts - Some helper scripts used during compilation
**Important Files**
In MR/Libs/Internal/MedPyExport/generate_binding/ you would find the following files:
- *make.sh* - bash script to start cmake building
- *MedPython/MedPython.i* - Main SWIG interface file for the binding
- *MedPython/medial-numpy.i* - Numpy SWIG interface file - to be able to use numpy's ndarrays
- *MedPython/MedPython.h* - Entry point for all .h files to be scanned by SWIG proccessor
- *MedPython/MedPython.c* - Entry point for all .c files to be scanned by SWIG proccessor
- *MedPython/pythoncode.i* - This is where we may add Python code to the binding.
- *MedPython/scripts/make_apply.py* - This is a script to scan and generate apply directives used for Numpy arrays.
- *MedPython/apply_directives.i* - A generated file, created by make_apply.py, containing apply autogenerated SWIG directives.
**Extending the Code**
 
****
```c++
// .h file for the class 'PidRepository'
#include "MedPyCommon.h"
class MedPidRepository;
class MPPidRepository {
public:
    MedPidRepository* o;
    /*  
    ...
    */
};
```
 
- Include MedPyCommon.h which contains some utilities and helper macros.
- Exported class name starts with 'MP' (for "Medial Python") to avoid name conflicts in the c++ code. The exported class is renamed to 'PidRepository' in the above example.
- MedPidRepository* o - pointer to the object instance we wrap. Note the class declaration - required so we can maintain simple header file and include the actual MedPidRepository only in implementation.
- Total seperation between code and headers - because SWIG need 'Simple' cpp files. Processing complex files with templates and C++11 code generated syntax errors during SWIG scan and should be avoided.
All .h files to be exported should have an include line in MedPyExport.h:
```c++
#ifndef __MED_PY_EXPORT_H
#define __MED_PY_EXPORT_H
#include "MedPyExportExample.h"
#include "MPPidRepository.h"
#include "MPDictionary.h"
/* ... */
```
This file is the entry point for the SWIG parser.
To use the class we would write in Python:
```python
import medpython as med
rep = med.PidRepository()
```
 
**Adding a new class**
Writing wrapper code for a class in the API :
```c++
class MPPidRepository {
public:
    MedPidRepository* o;
    MPPidRepository();
    ~MPPidRepository();
    
    int read_all(const string &conf_fname);
    string dict_name(int section_id, int id);
    std::vector<bool> dict_prep_sets_lookup_table(int section_id, const std::vector<std::string> &set_names);
/* ... */
```
 
- Basic types are automatically mapped to Python maps: 
```
. The mapped symbol for vector is '
```
'. using the imported namespace symbol without the 'std::' prefix fails in case of vector, I wasn't able to fix this issue yet. For now use '
```
'.
Implementation code in the .cpp file will look like this
```c++
#include "MPPidRepository.h"
#include "InfraMed/InfraMed/MedPidRepository.h"
MPPidRepository::MPPidRepository() : o(new MedPidRepository()) {};
MPPidRepository::~MPPidRepository() { delete o; };
/* ... */
int MPPidRepository::read_all(const std::string &conf_fname){ return o->read_all(conf_fname); }
string MPPidRepository::dict_name(int section_id, int id) { return o->dict.name(section_id, id); }
/* ... */
```
 
**properties**
 
****
```c++
class MPSamples {
    /* ... */
    int MEDPY_GET_time_unit();
    void MEDPY_SET_time_unit(int new_time_unit);
    /* ... */
```
****
 
- * The property name in the above example will be 'time*
 
**
```python
>>> s = med.Samples()
>>> s.time_unit
1
```
- You may implement object properties by implemennting a function with the prefix 
```
 or 
```
 or both.
- You may create a read only property by ommiting the 
```
 function.
**
 
**Static const variables**
Static variable are converted to class variables in Python:
```c++
class MPTime {
public:
    // names for timing options
     static const int Undefined;
     static const int Date;
     static const int Years;
/* ... */
```
 
Implementation in C++ file:
```c++
#include "MPTime.h"
#include "MedTime/MedTime/MedTime.h"
const int MPTime::Undefined = MedTime::Undefined;
const int MPTime::Date = MedTime::Date;
```
 
```
```
print med.Time.Date 
```
 
**Iterators**
Example for implementing an **array iterator**:
```c++
class MPSigVectorAdaptor {
public:
    /* ... */
    int __len__();
    MPSig __getitem__(int i);
    /* ... */
```
- Array iterator - index is always int
- Class name must end with "VectorAdaptor" suffix.
- Class must implement 
```
 and 
```
- Python code in 
```
 creates the iterator type for this class. look at 
```
Example implementing a **map iterator**:
```c++
class MPStringFeatureAttrMapAdaptor {
    std::map<std::string, FeatureAttr>* o;
public:
    /* ... */
    int __len__();
    MPFeatureAttr __getitem__(std::string key);
    void __setitem__(std::string key, MPFeatureAttr& val);
    std::vector<std::string> keys();
    /* ... */
```
- Map iterator - index is usually of string type.
- Class name must end with "MapAdaptor" suffix.
- Class must implement 
```
 and 
```
- Other Python special functions may be implemented as well, i.e. 
```
 and 
```
- Python code in 
```
 creates the iterator type for this class. look at 
```
**NumPy Arrays**
Input arrays are defined as arrays of data that are passed into a routine but are not altered or returned to the user.
The Python input array is therefore allowed to be almost any Python sequence(such as a list) that can be converted to the requested type of array. Example:
```c++
class MPPidRepository {
    /* ... */
    int read_all(string conf_fname, MEDPY_NP_INPUT(int* pids_to_take, int num_pids_to_take) ...)
```
 
```
```
```
void MedPyExportExample::numpy_vec_in_out(MEDPY_NP_INPLACE(double* vec, int m))
```
 
Output arrays (Memory Managed Argout View Arrays) are arrays that appear in the input arguments in C++, but are in fact output arrays. 
If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list. 
The Python user does not pass these arrays in, they simply get returned. 
Additinal parameter in the c++ code sets length of the allocated memory. 
The array should be allocated using malloc() call. 
Python will issue the free() call when it's time to dispose the associated python object using the GC or Python's del call. Example:
```c++
class MPFeatures {
    /* ... */
    void MEDPY_GET_weights(MEDPY_NP_OUTPUT(float** float_out_buf, int* float_out_buf_len));
    /* ... */
```
Variant output - allows you to specify the output type of the array you return. Example:
```c++
void getitem(string key, MEDPY_NP_VARIANT_OUTPUT(void** var_arr, int* var_arr_sz, int* var_arr_type)) {
    *var_arr_sz = 0;
    if (key == "i")
    {
        *var_arr = (void*)malloc(sizeof(int) * 10);
        *var_arr_sz = 10;
        *var_arr_type = (int)MED_NPY_TYPES::NPY_INT;
        for (int i = 0; i < 10; i++)
            ((*(int**)var_arr))[i] = i * 5;
    }
    else if (key == "d")
    {
        *var_arr = (void*)malloc(sizeof(double) * 20);
        *var_arr_sz = 20;
        *var_arr_type = (int)MED_NPY_TYPES::NPY_DOUBLE;
        for (int i = 0; i < 20; i++)
            ((*(double**)var_arr))[i] = i * 2.5;
    }
    else if (key == "f")
    {
        *var_arr = (void*)malloc(sizeof(float) * 15);
        *var_arr_sz = 15;
        *var_arr_type = (int)MED_NPY_TYPES::NPY_FLOAT;
        for (int i = 0; i < 15; i++)
            ((*(float**)var_arr))[i] = i * 0.33333f;
    }
    else if (key == "n")
    {
        *var_arr = nullptr;
    }
}
```
 
You should pack a the binary array the way NumPy would expect it. Avalable types are:
```c++
    NPY_BOOL = 0,
    NPY_BYTE, NPY_UBYTE,
    NPY_SHORT, NPY_USHORT,
    NPY_INT, NPY_UINT,
    NPY_LONG, NPY_ULONG,
    NPY_LONGLONG, NPY_ULONGLONG,
    NPY_FLOAT, NPY_DOUBLE, NPY_LONGDOUBLE,
    NPY_CFLOAT, NPY_CDOUBLE, NPY_CLONGDOUBLE,
    NPY_OBJECT = 17,
    NPY_STRING, NPY_UNICODE,
    NPY_VOID,
    NPY_DATETIME, NPY_TIMEDELTA, NPY_HALF,
    NPY_NTYPES,
    NPY_NOTYPE,
    NPY_CHAR,
    NPY_USERDEF = 256,
    NPY_NTYPES_ABI_COMPATIBLE = 21
```
 
**Other Tools and helper functions**
- Use MEDPY_DOC macro to add docstrings. These will be displayed when python help() is used:
```c++
MEDPY_DOC(function_or_class_name, docstring)
```
- Use MEDPY_IGNORE() macro to make swig skip the enclosed text.
```c++
MEDPY_IGNORE(...)
// same as:
#ifdef SWIG
// ...
#endif
```
- Use buf_*to_*vector() to convert an input buffer to a vector
```c++
void MPFeatures::get_as_matrix(MPMat& mat, const vector<string> names, MEDPY_NP_INPUT(int* int_in_buf, int int_in_buf_len)) const {
    vector<int> idx;
    buf_to_vector(int_in_buf, int_in_buf_len, idx);
    o->get_as_matrix(*(mat.o), names, idx);
}
```
- Use vector_*to_*buf() to convert a vector into an output buffer:
```c++
void MPFeatures::MEDPY_GET_weights(MEDPY_NP_OUTPUT(float** float_out_buf, int* float_out_buf_len)) {
    vector_to_buf(o->weights, float_out_buf, float_out_buf_len);
}
```
 
**Installation**
Each user compiles his own version. 
There is is script in /opt/medial/python36/usr/lib/python3.6/site-packages/sitecustomize.py which will load the user's compiled binding from the git build location.
Upon regular execution of the python 3.6 interpreter, the binding should be available :
```
 
 
 
 
