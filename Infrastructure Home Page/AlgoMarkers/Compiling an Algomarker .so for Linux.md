# Compiling an Algomarker .so for Linux
## Compile Without docker for Product:
```
$MR_ROOT/Libs/Internal/AlgoMarker/full_build.sh
#check output in $MR_ROOT/Libs/Internal/AlgoMarker/Linux/Release
#or more specificaly: $MR_ROOT/Libs/Internal/AlgoMarker/build/Release//AlgoMarker/libdyn_AlgoMarker.so
#The compiled output without debug symbols (more compressed): $MR_ROOT/Libs/Internal/AlgoMarker/Linux/Release/libdyn_AlgoMarker.so
```
 
## NOT NEEDED ANYMORE
## 
 
1. 
```
cd  $MR_ROOT/Projects/Scripts
git pull
cd  $MR_ROOT/Projects/Scripts/Docker/medbuild_algomarker2
./make.sh
```
2. 
```
Your git username:shlomi-internal
Your git password:
AM GIT tag to build(can be 'master' or 'lc_1_140719'):
```
3. 
## Important note regarding -march=native vs. -march=x86-64
Since compiling using -march=native can generate code that might randomly crash on different hardware (mainly because of different supported CPU features), We use  -march=x86-64 to generate an executable that will always work.
However, that **may cause slight differences in float computation** beween our native build that runs on the nodes and the build for external use with -march=x86-64, and possibly other issues may appear.
For example , we discovered at some point that there was a change in a given score: pred=0.100948 vs  pred=0.099901 that was cause by this difference. Exploring the matrix revealed that some slope feature was set to a 0 and on the other build a number as small as 10^-17 was assigned instead.
For now, we have no solution but to be aware of the issue when comparing scores from binaries compiled on different architectures or to deal with this issue using eliminating these small changes using matrix normalization.
You may temporarily change your binaries to compile with -march=x86-64 if you edit your CMakeLists.txt and change it.
You may also choose to compile your docker build with march=native by specifying to docker build command the following flag: --build-arg BUILD_MARCH=native
## 
1. 
```
cd  $MR_ROOT/Projects/Scripts
git pull
cd  $MR_ROOT/Projects/Scripts/Docker/medbuild_algomarker1
./make.sh
```
2. 
```
Your git username:Shlomi
Your git password:
AM GIT tag to build(can be '25102018_1' (1.0.4) or 'AlgoMarker_1.0.5.0'):
```
3. 
 
 
### OLD WAY :
1. 
2. 
3. 
 
### some insights about the building process:
1. compile everthing but the algomarker statically, generating .a (archive) files. 
2. Everything must be recompiled to use -fPIC flag.
3. Not everything can be recompiled using the create_cmake_files script - Especially the libs in external and boost.
4. some editing of Make files was required, especially in LightGBM
5. Compile the Algomarker as a shared object and link everything into it statically.
6. Use ldd to make sure it doesn't depand on non-system .so files.
7. Use a test program to load it dynamically using opendl().
1. 
****
 Expand source
```
# Boost.Build Configuration
# Automatically generated by bootstrap.sh
import option ;
import feature ;
# Compiler configuration. This definition will be used unless
# you already have defined some toolsets in your user-config.jam
# file.
if ! gcc in [ feature.values <toolset> ]
{
    using gcc ;
}
project : default-build <toolset>gcc ;
# Python configuration
import python ;
if ! [ python.configured ]
{
    using python : 3.6 : /opt/medial/dist/usr ;
}
path-constant ICU_PATH : /usr ;
# List of --with-<library> and --without-<library>
# options. If left empty, all libraries will be built.
# Options specified on the command line completely
# override this variable.
libraries =  ;
# These settings are equivivalent to corresponding command-line
# options.
option.set prefix : /usr/local/boost ;
option.set exec-prefix : /usr/local/boost ;
option.set libdir : /usr/local/boost/lib ;
option.set includedir : /usr/local/boost/include ;
# Stop on first error
option.set keep-going : false ;
```
execute:
```
sudo ./b2 --clean
sudo ./b2 link=static variant=release linkflags=-static-libstdc++ -j8 cxxflags="-fPIC"
# To save some time use: --with-filesystem --with-program_options --with-system --with-regex 
sudo cp ./stage/lib/libboost_* /build/staticlib/
```
2. 
Build XGBoost:
```
cd $MR_ROOT/Libs/External/xgboost
make clean
#The clean doesn't delete .a files
find . -name '*.a' -exec rm {} \;
mkdir -p ./rabit/lib/                   #This empty dir is not created by git and the build process fails
make -j8                                # used to be build.sh -j8
cp ./lib/libxgboost.a /build/staticlib/
cp ./rabit/lib/librabit_empty.a /build/staticlib/
cp ./dmlc-core/libdmlc.a /build/staticlib/
```
3. 
Build LightGBM:
Put the following CMakeLists.txt file in directory $MR_ROOT/Libs/External/LightGBM/LightGBM/
****
 Expand source
```
cmake_minimum_required(VERSION 2.8)
PROJECT(lightgbm)
OPTION(USE_MPI "MPI based parallel learning" OFF)
OPTION(USE_OPENMP "Enable OpenMP" ON)
OPTION(USE_GPU "Enable GPU-accelerated training" OFF)
OPTION(USE_SWIG "Enable SWIG to generate Java API" OFF)
OPTION(USE_HDFS "Enable HDFS support (EXPERIMENTAL)" OFF)
OPTION(USE_R35 "Set to ON if your R version is not smaller than 3.5" OFF)
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "4.8.2")
    message(FATAL_ERROR "Insufficient gcc version")
  endif()
endif()
if(USE_SWIG)
  find_package(SWIG REQUIRED)
  find_package(Java REQUIRED)
  find_package(JNI REQUIRED)
  include(UseJava)
  include(UseSWIG)
  set(SWIG_CXX_EXTENSION "cxx")
  set(SWIG_EXTRA_LIBRARIES "")
  set(SWIG_JAVA_EXTRA_FILE_EXTENSIONS ".java" "JNI.java")
  set(SWIG_MODULE_JAVA_LANGUAGE "JAVA")
  set(SWIG_MODULE_JAVA_SWIG_LANGUAGE_FLAG "java")
  set(CMAKE_SWIG_OUTDIR "${CMAKE_CURRENT_BINARY_DIR}/java")
  include_directories(Java_INCLUDE_DIRS)
  include_directories(JNI_INCLUDE_DIRS)
  include_directories($ENV{JAVA_HOME}/include)
  FILE(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/com/microsoft/ml/lightgbm/linux/x86_64")
  include_directories($ENV{JAVA_HOME}/include/linux)
endif(USE_SWIG)
if(USE_R35)
    ADD_DEFINITIONS(-DR_VER_ABOVE_35)
endif()
if(USE_MPI)
    find_package(MPI REQUIRED)
    ADD_DEFINITIONS(-DUSE_MPI)
    MESSAGE(${MPI_LIBRARIES})
    MESSAGE(${MPI_CXX_LIBRARIES})
else()
    ADD_DEFINITIONS(-DUSE_SOCKET)
endif(USE_MPI)
if(USE_OPENMP)
    find_package(OpenMP REQUIRED)
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
else()
    # Ignore unknown #pragma warning
    if( (CMAKE_CXX_COMPILER_ID MATCHES "[cC][lL][aA][nN][gG]")
      OR (CMAKE_CXX_COMPILER_ID MATCHES "[gG][nN][uU]"))
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-unknown-pragmas")
    endif()
endif(USE_OPENMP)
if(USE_GPU)
    SET(BOOST_COMPUTE_HEADER_DIR ${PROJECT_SOURCE_DIR}/compute/include)
    include_directories (${BOOST_COMPUTE_HEADER_DIR})
    find_package(OpenCL REQUIRED)
    include_directories(${OpenCL_INCLUDE_DIRS})
    MESSAGE(STATUS "OpenCL include directory:" ${OpenCL_INCLUDE_DIRS})
    if (WIN32)
        set(Boost_USE_STATIC_LIBS ON)
    endif()
    find_package(Boost 1.56.0 COMPONENTS filesystem system REQUIRED)
    if (WIN32)
        # disable autolinking in boost
        add_definitions(-DBOOST_ALL_NO_LIB)
    endif()
    include_directories(${Boost_INCLUDE_DIRS})
    ADD_DEFINITIONS(-DUSE_GPU)
endif(USE_GPU)
if(USE_HDFS)
    find_package(JNI REQUIRED)
    find_path(HDFS_INCLUDE_DIR hdfs.h REQUIRED)
    find_library(HDFS_LIB NAMES hdfs REQUIRED)
    include_directories(${HDFS_INCLUDE_DIR})
    ADD_DEFINITIONS(-DUSE_HDFS)
    SET(HDFS_CXX_LIBRARIES ${HDFS_LIB} ${JAVA_JVM_LIBRARY})
endif(USE_HDFS)
if(UNIX OR MINGW OR CYGWIN)
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wunused-variable -Wformat -Wparentheses -Wmissing-braces -Wreturn-type -Werror=return-type --std=c++11 -Wno-write-strings -Wuninitialized -Wreturn-type -fopenmp -msse2 -msse3 -msse4 -march=native --param inline-unit-growth=1000000 -Ofast -fomit-frame-pointer -fPIC -I/server/Work/Applications/R/R-Latest/include")
endif()
SET(LightGBM_HEADER_DIR ${PROJECT_SOURCE_DIR}/include)
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR})
SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR})
include_directories(${LightGBM_HEADER_DIR})
if(USE_MPI)
  include_directories(${MPI_CXX_INCLUDE_PATH})
endif(USE_MPI)
file(GLOB SOURCES
    src/application/*.cpp
    src/boosting/*.cpp
    src/io/*.cpp
    src/metric/*.cpp
    src/objective/*.cpp
    src/network/*.cpp
    src/treelearner/*.cpp
)
#add_executable(lightgbm src/main.cpp ${SOURCES})
add_library(_lightgbm STATIC src/c_api.cpp src/lightgbm_R.cpp  ${SOURCES})
if(USE_SWIG)
  set_property(SOURCE swig/lightgbmlib.i PROPERTY CPLUSPLUS ON)
  LIST(APPEND swig_options -package com.microsoft.ml.lightgbm)
  set_property(SOURCE swig/lightgbmlib.i PROPERTY SWIG_FLAGS "${swig_options}")
  swig_add_module(_lightgbm_swig java swig/lightgbmlib.i)
  swig_link_libraries(_lightgbm_swig _lightgbm)
  # needed to ensure linux build does not have lib specified twice, eg liblib_lightgbm_swig
  set_target_properties(_lightgbm_swig PROPERTIES PREFIX "")
  # needed in latest version of cmake for VS and MINGW builds to ensure output dll has lib prefix
  set_target_properties(_lightgbm_swig PROPERTIES OUTPUT_NAME "lib_lightgbm_swig")
  add_custom_command(TARGET _lightgbm_swig POST_BUILD
      COMMAND "${Java_JAVAC_EXECUTABLE}" -d . java/*.java
      COMMAND cp "${PROJECT_SOURCE_DIR}/*.a" com/microsoft/ml/lightgbm/linux/x86_64
      COMMAND "${Java_JAR_EXECUTABLE}" -cf lightgbmlib.jar com)
endif(USE_SWIG)
if(USE_MPI)
  TARGET_LINK_LIBRARIES(lightgbm ${MPI_CXX_LIBRARIES})
  TARGET_LINK_LIBRARIES(_lightgbm ${MPI_CXX_LIBRARIES})
endif(USE_MPI)
if(USE_GPU)
  TARGET_LINK_LIBRARIES(lightgbm ${OpenCL_LIBRARY} ${Boost_LIBRARIES})
  TARGET_LINK_LIBRARIES(_lightgbm ${OpenCL_LIBRARY} ${Boost_LIBRARIES})
endif(USE_GPU)
if(USE_HDFS)
  TARGET_LINK_LIBRARIES(lightgbm ${HDFS_CXX_LIBRARIES})
  TARGET_LINK_LIBRARIES(_lightgbm ${HDFS_CXX_LIBRARIES})
endif(USE_HDFS)
install(TARGETS _lightgbm
        RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/bin
        LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
        ARCHIVE DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
install(DIRECTORY ${LightGBM_HEADER_DIR}/LightGBM DESTINATION ${CMAKE_INSTALL_PREFIX}/include)
```
Execute in command line:
```
cd $MR_ROOT/Libs/External/LightGBM/LightGBM/
rm -rf ./build
mkdir build
cmake ..
make -j8
cd ..
cp ../lib_lightgbm.a /build/staticlib/
```
4. 
 
 
 
Insights:
1. for some reason we compile use Libs/Internal/libgbm using include dir $R_INCL_DIR which points to /server/Work/Applications/R/R-Latest/include , which is an old windows version. This causes a missing symbol - R_finite() is not defined. To temporarily fix this we can #define HAVE_WORKING_FINITE and the math.h version will be linked. For the long run we should recompile R on Linux and change $R_INCL_DIR to point it.
2. To hide internal function we should use flag 
```
```
3. 
```
 
 
 
 
 
